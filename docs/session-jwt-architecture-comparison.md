# セッション vs JWT アーキテクチャ比較詳細資料

**Phase2 Step3 学習成果物**

---

## 🏗️ アーキテクチャ図解

### セッション方式（ステートフル認証）

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│     Client      │    │     Server      │    │  Session Store  │
│                 │    │                 │    │  (Redis/Memory) │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ 1. ログイン要求 │───▶│ 2. 認証処理     │    │                 │
│                 │    │                 │    │                 │
│ 3. SessionID    │◀───│ 4. Session作成  │───▶│ 5. データ保存   │
│    Cookie受信   │    │    ID発行       │    │   SessionID     │
│                 │    │                 │    │   UserData      │
├─────────────────┤    ├─────────────────┤    │   Expiry        │
│ 6. API要求      │───▶│ 7. SessionID    │───▶│ 8. データ検索   │
│   +Cookie       │    │    チェック     │    │                 │
│                 │    │                 │◀───│ 9. ユーザー情報 │
│ 11. レスポンス  │◀───│ 10. 処理実行    │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

**特徴:**

- サーバーが認証状態を保持（ステートフル）
- セッションストアが必須（Redis, Memory, DB）
- Cookie による自動送信
- セッション無効化が即座に可能

### JWT 方式（ステートレス認証）

```
┌─────────────────┐    ┌─────────────────┐
│     Client      │    │     Server      │
│                 │    │                 │
├─────────────────┤    ├─────────────────┤
│ 1. ログイン要求 │───▶│ 2. 認証処理     │
│                 │    │                 │
│ 3. JWT受信      │◀───│ 4. JWT生成      │
│                 │    │   (Header.      │
│                 │    │    Payload.     │
│                 │    │    Signature)   │
├─────────────────┤    ├─────────────────┤
│ 5. API要求      │───▶│ 6. JWT検証      │
│   +Bearer JWT   │    │   - 署名確認    │
│                 │    │   - 有効期限    │
│                 │    │   - ペイロード  │
│ 8. レスポンス   │◀───│ 7. 処理実行     │
└─────────────────┘    └─────────────────┘
```

**特徴:**

- サーバーは状態を保持しない（ステートレス）
- 外部ストレージ不要
- Authorization ヘッダによる明示的送信
- トークン内に必要な情報を含有

---

## ⚡ パフォーマンス特性比較

### CPU 使用量

| 方式           | 認証生成 | 認証検証 | 特徴                                     |
| :------------- | :------- | :------- | :--------------------------------------- |
| **セッション** | 低       | 極低     | SessionID 生成のみ、検証はメモリアクセス |
| **JWT**        | 高       | 高       | 署名生成/検証で CPU 集約的               |

### メモリ使用量

| 方式           | サーバーメモリ | スケール時     | 特徴                           |
| :------------- | :------------- | :------------- | :----------------------------- |
| **セッション** | 高             | 共有ストア必要 | ユーザー数に比例してメモリ使用 |
| **JWT**        | 0              | 不要           | 完全ステートレス               |

### ネットワーク使用量

| 方式           | トークンサイズ      | 送信頻度     | 特徴             |
| :------------- | :------------------ | :----------- | :--------------- |
| **セッション** | 小（32-64 bytes）   | 毎リクエスト | SessionID のみ   |
| **JWT**        | 大（200-500 bytes） | 毎リクエスト | ユーザー情報含有 |

---

## 🔄 実際の動作フロー比較

### セッション方式の動作

```javascript
// 1. セッション作成
const sessionId = crypto.randomBytes(32).toString("hex");
sessionStore.set(sessionId, {
  userId: user.id,
  username: user.name,
  role: user.role,
  createdAt: new Date(),
  expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30分
});

// 2. Cookie設定
res.cookie("sessionId", sessionId, {
  httpOnly: true,
  secure: true,
  maxAge: 30 * 60 * 1000,
});

// 3. 認証チェック（各リクエストで）
const sessionData = sessionStore.get(req.cookies.sessionId);
if (!sessionData || sessionData.expiresAt < new Date()) {
  return res.status(401).json({ error: "認証が必要です" });
}
```

### JWT 方式の動作

```javascript
// 1. JWT生成
const payload = {
  userId: user.id,
  username: user.name,
  role: user.role,
  iat: Math.floor(Date.now() / 1000),
  exp: Math.floor(Date.now() / 1000) + 30 * 60, // 30分後
};
const token = jwt.sign(payload, process.env.JWT_SECRET);

// 2. レスポンス
res.json({ token });

// 3. 認証チェック（各リクエストで）
const token = req.headers.authorization?.replace("Bearer ", "");
try {
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  // decodedに含まれる情報を直接使用
} catch (error) {
  return res.status(401).json({ error: "無効なトークンです" });
}
```

---

## 📊 スケーラビリティ比較

### 水平スケール（サーバー数増加）

#### セッション方式

```
Load Balancer
     │
┌────▼─────┐  ┌─────────────┐  ┌─────────────┐
│ Server 1 │  │  Server 2   │  │   Server 3  │
└────┬─────┘  └──────┬──────┘  └──────┬──────┘
     │               │                │
     └───────────────▼────────────────┘
            ┌─────────────────┐
            │  Shared Session │
            │     Store       │
            │   (Redis)       │
            └─────────────────┘
```

**必要な追加リソース:**

- 共有セッションストア（Redis 等）
- セッションデータの同期機構
- 障害時のセッション復旧機能

#### JWT 方式

```
Load Balancer
     │
┌────▼─────┐  ┌─────────────┐  ┌─────────────┐
│ Server 1 │  │  Server 2   │  │   Server 3  │
│          │  │             │  │             │
│ 完全独立 │  │   完全独立  │  │   完全独立  │
└──────────┘  └─────────────┘  └─────────────┘
```

**追加リソース不要:**

- 各サーバーが完全に独立
- 共有ストレージ不要
- 即座にスケールアウト可能

---

## 🛡️ セキュリティ比較

### セッション方式のセキュリティ

| 脅威                       | 対策                   | 実装コスト |
| :------------------------- | :--------------------- | :--------- |
| **Session Fixation**       | セッション ID 再生成   | 中         |
| **CSRF**                   | CSRF トークン必須      | 高         |
| **セッションハイジャック** | HTTPS + Secure Cookie  | 低         |
| **無効化**                 | サーバー側で即座に削除 | 低         |

### JWT 方式のセキュリティ

| 脅威                 | 対策                           | 実装コスト |
| :------------------- | :----------------------------- | :--------- |
| **None Algorithm**   | アルゴリズム検証               | 低         |
| **ブルートフォース** | 強力な秘密鍵（256bit+）        | 低         |
| **Token 盗難**       | 短い有効期限 + Refresh         | 高         |
| **無効化**           | ブラックリスト or 短い有効期限 | 高         |

---

## 💡 適用場面の判断基準

### セッション方式が適している場面

- **シングルサーバー**: スケールアウトの予定なし
- **即座な無効化**: ログアウト時の即時セッション無効化が重要
- **CPU 節約**: 認証処理での CPU 使用量を抑えたい
- **従来システム**: 既存のセッション基盤を活用

### JWT 方式が適している場面

- **マイクロサービス**: 複数サービス間での認証共有
- **水平スケール**: サーバー数の柔軟な増減が必要
- **ステートレス設計**: サーバーの状態管理を避けたい
- **モバイルアプリ**: ネイティブアプリでの認証

---

## 🔍 実装時の注意点

### セッション方式の注意点

```javascript
// ❌ 危険: セッションIDの推測可能性
const sessionId = Date.now().toString(); // 連番で推測可能

// ✅ 安全: 暗号学的に安全な乱数
const sessionId = crypto.randomBytes(32).toString("hex");

// ❌ 危険: セッション無効化なし
// ログアウト時にサーバー側のセッションを削除していない

// ✅ 安全: 適切な無効化
sessionStore.delete(sessionId);
res.clearCookie("sessionId");
```

### JWT 方式の注意点

```javascript
// ❌ 危険: 弱い秘密鍵
const secret = "secret"; // 辞書攻撃で破られる

// ✅ 安全: 強力な秘密鍵
const secret = crypto.randomBytes(32).toString("hex"); // 256bit

// ❌ 危険: 機密情報をペイロードに含める
const payload = {
  userId: user.id,
  password: user.password, // 暗号化されていない
};

// ✅ 安全: 必要最小限の情報のみ
const payload = {
  userId: user.id,
  role: user.role,
  iat: Math.floor(Date.now() / 1000),
  exp: Math.floor(Date.now() / 1000) + 15 * 60, // 15分
};
```

---

## 📈 パフォーマンステスト結果例

### テスト環境

- CPU: 2.4GHz 4 cores
- Memory: 8GB
- Node.js: v18.17.0
- 同時認証検証回数: 1,000 回

### 結果

| 方式           | 平均実行時間 | メモリ使用量 | CPU 使用率 |
| :------------- | :----------- | :----------- | :--------- |
| **セッション** | 0.12ms       | 200KB        | 5%         |
| **JWT**        | 1.45ms       | 0KB          | 25%        |

### 考察

1. **セッション方式**

   - 検証が高速（メモリアクセスのみ）
   - メモリ使用量がユーザー数に比例
   - CPU 使用量は最小

2. **JWT 方式**
   - 署名検証で CPU 使用量増加
   - メモリ使用量ゼロ（ステートレス）
   - スケールアウト時の優位性

---

## 🎯 学習のまとめ

### 重要なポイント

1. **アーキテクチャの違い**

   - セッション: ステートフル（サーバーが状態保持）
   - JWT: ステートレス（情報がトークンに含有）

2. **パフォーマンス特性**

   - セッション: 高速だがメモリ使用
   - JWT: CPU 使用だがメモリ不要

3. **スケーラビリティ**

   - セッション: 共有ストア要
   - JWT: 即座にスケール可能

4. **セキュリティ考慮事項**
   - 両方式とも適切な対策が必要
   - 無効化戦略の違いが重要

### Phase3 への準備

この理解を基に、Phase3 では実際の認証 API で JWT 方式を実装し、より実践的な知識を身に付けます。

---

_Phase2 Step3 完了 - 次は Step4「JWT 実装基礎」へ_
